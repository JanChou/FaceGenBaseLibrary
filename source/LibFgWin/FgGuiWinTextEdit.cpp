//
// Copyright (c) 2015 Singular Inversions Inc. (facegen.com)
// Use, modification and distribution is subject to the MIT License,
// see accompanying file LICENSE.txt or facegen.com/base_library_license.txt
//
// Authors:     Andrew Beatty
// Created:     Oct 18, 2011
//

#include "stdafx.h"

#include "FgGuiApiText.hpp"
#include "FgGuiWin.hpp"
#include "FgThrowWindows.hpp"

using namespace std;

struct  FgGuiWinTextEdit : public FgGuiOsBase
{
    HWND                hwndText;
    HWND                hwndThis;
    FgGuiApiTextEdit    m_api;
    FgVect2UI           m_fontDims;
    FgString            m_lastVal;      // Need to filter notifcations for actual changes

    FgGuiWinTextEdit(const FgGuiApiTextEdit & api)
        : m_api(api), m_fontDims(16,16)
    {}

    virtual void
    create(HWND parentHwnd,int ident,const FgString &,DWORD extStyle,bool visible)
    {
        FgCreateChild   cc;
        cc.extStyle = extStyle;
        cc.visible = visible;
        fgCreateChild(parentHwnd,ident,this,cc);
    }

    virtual void
    destroy()
    {
        // Automatically destroys children first:
        DestroyWindow(hwndThis);
    }

    virtual FgVect2UI
    getMinSize() const
    {return FgVect2UI(100,m_fontDims[1]+6); }

    virtual FgVect2B
    wantStretch() const
    {return FgVect2B(true,false); }

    virtual void
    updateIfChanged()
    {
        if (g_gg.dg.update(m_api.updateFlagIdx))
            update();
    }

    virtual void
    moveWindow(FgVect2I lo,FgVect2I sz)
    {MoveWindow(hwndThis,lo[0],lo[1],sz[0],sz[1],FALSE); }

    virtual void
    showWindow(bool s)
    {ShowWindow(hwndThis,s ? SW_SHOW : SW_HIDE); }
    
    void
    update()
    {
        const FgString &    txt = m_api.getInput();
        if (txt != m_lastVal) {
            // We do not call updateWindow here since we don't want to update the text in the
            // box while the user is typing, so we let the client call only when that text is valid
            // (and thus idempotent).
            m_lastVal = txt;
            SetWindowText(hwndText,txt.as_wstring().c_str());
        }
    }

    LRESULT
    wndProc(HWND hwnd,UINT message,WPARAM wParam,LPARAM lParam)
    {
        switch (message)
        {
            case WM_CREATE:
            {
                hwndThis = hwnd;
                hwndText = 
                    CreateWindowEx(0,
                        TEXT("edit"),
                        NULL,
                        WS_CHILD | WS_VISIBLE | WS_BORDER | ES_LEFT,
                        0,0,0,0,            // Will be sent MOVEWINDOW messages.
                        hwnd,
                        HMENU(1),
                        s_fgGuiWin.hinst,
                        NULL);              // No WM_CREATE parameter
                FGASSERTWIN(hwndText != 0);
                TEXTMETRIC  tm;
                GetTextMetrics(GetDC(hwndThis),&tm);
                m_fontDims[0] = tm.tmAveCharWidth;
                m_fontDims[1] = tm.tmHeight + tm.tmExternalLeading;
                update();
                return 0;
            }
            case WM_SIZE:   // Sends new size of client area.
            {
                int     wid = LOWORD(lParam);
                int     hgt = HIWORD(lParam);
                if (wid*hgt > 0)
                    MoveWindow(hwndText,0,0,wid,hgt,TRUE);
                return 0;
            }
            case WM_COMMAND:
            {
                int     nc = HIWORD(wParam);
                // EN_CHANGE is sent after the text is updated to reflect the user's typing (unlike
                // EN_UPDATE which is sent before), however both messages are also generated by
                // SetWindowText and other windows draw-related events so we need to filter for
                // actual changes to avoid an infinite loop and superflous recalcs / redraws:
                if (nc == EN_CHANGE) {
                    int len = GetWindowTextLength(hwndText);
                    // Leave room for NULL:
                    wstring     str(len+1,wchar_t(0));
                    // Windows only retrieves argLen-1 chars then sends a NULL:
                    GetWindowText(hwndText,&str[0],len+1);
                    // Use c string cons to avoid including NULL in string itself:
                    FgString    txt(&str[0]);
                    if (txt != m_lastVal) {
                        m_lastVal = txt;
                        m_api.setOutput(txt);
                    }
                }
                return 0;
            }
        }
        return DefWindowProc(hwnd,message,wParam,lParam);
    }
};

FgSharedPtr<FgGuiOsBase>
fgGuiGetOsInstance(const FgGuiApiTextEdit & def)
{return FgSharedPtr<FgGuiOsBase>(new FgGuiWinTextEdit(def)); }
